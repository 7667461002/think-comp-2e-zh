# 二、图

本书的前三章有关一些模型，它们描述了由组件和组件之间的连接组成的系统。例如，在生态食物网中，组件是物种，连接代表捕食者和猎物的关系。

在本章中，我介绍了 NetworkX，一个用于构建和研究这些模型的 Python 包。我们从 Erdős-Rényi 模型开始，它具有一些有趣的数学属性。在下一章中，我们将介绍更有用的，解释现实系统的模型。

本章的代码在本书仓库中的`chap02.ipynb`中。使用代码的更多信息请参见第（？）章。

## 2.1 图是什么？

![](img/2-1.png)

> 图 2.1：表示社交网络的有向图

对于大多数人来说，图是数据集的视觉表示，如条形图或股票价格对于时间的绘图。这不是本章的内容。

在本章中，图是一个系统的表示，它包含离散的互连元素。元素由节点表示，互连由边表示。

例如，你可以表示一个路线图，每个城市都是一个节点，每个城市之间的路线是一条边。或者你可以表示一个社交网络，每个人是节点，如果他们是朋友，两个人之间有边，否则没有。

在某些图中，边具有长度，成本或权重等属性。例如，在路线图中，边的长度可能代表两个城市之间的距离，或旅行时间。在社交网络中，可能会有不同的边来表示不同种类的关系：朋友，商业伙伴等。

边可以是有向或无向的，这取决于它们表示的关系是不对称的还是对称的。在路线图中，你可能会使用有向边表示单向街道，使用无向边表示双向街道。在某些社交网络，如 Facebook，好友是对称的：如果 A 是 B 的朋友，那么 B 也是 A 的朋友。但在 Twitter 上，“关注”关系并不对称；如果 A 关注了 B，这并不意味着 B  关注 A。因此，你可以使用无向边来表示 Facebook 网络，并将有向边用于 Twitter。

图具有有趣的数学属性，并且有一个称为图论的数学分支，用于研究它们。

图也很有用，因为有许多现实世界的问题可以使用图的算法来解决。例如，Dijkstra 的最短路径算法，是从图中找到某个节点到所有其他节点的最短路径的有效方式。路径是两个节点之间的，带有边的节点序列。

图的节点通常以圆形或方形绘制，边通常以直线绘制。例如，上面的有向图中，节点可能代表在 Twitter 上彼此“关注”的三个人。线的较厚部分表示边的方向。在这个例子中，爱丽丝和鲍勃相互关注，都关注查克，但查克没有关注任何人。

下面的无向图展示了美国东北部的四个城市；边上的标签表示驾驶时间，以小时为单位。在这个例子中，节点的位置大致对应于城市的地理位置，但是通常图的布局是任意的。

## 2.2 NetworkX

![](img/2-2.png)

> 图 2.2：表示城市和高速公路的无向图

为了表示图，我们将使用一个名为 NetworkX 的包，它是 Python 中最常用的网络库。你可以在 <https://networkx.github.io/> 上阅读更多信息，但是我们之后会解释。

我们可以通过导入 NetworkX 和实例化`nx.DiGraph`来创建有向图：

```py

import networkx as nx
G = nx.DiGraph()
```

通常将 NetworkX 导入为`nx`。此时，`G`是一个`DiGraph`对象，不包含节点和边。我们可以使用`add_node`方法添加节点：

```py

G.add_node('Alice')
G.add_node('Bob')
G.add_node('Chuck')
```

现在我们可以使用`nodes`方法获取节点列表：

```py

>>> G.nodes()
['Alice', 'Bob', 'Chuck']
```

添加边的方式几乎相同：

```py

G.add_edge('Alice', 'Bob')
G.add_edge('Alice', 'Chuck')
G.add_edge('Bob', 'Alice')
G.add_edge('Bob', 'Chuck')
```

我们可以使用`edges`来获取边的列表：

```py
>>> G.edges()
[('Alice', 'Bob'), ('Alice', 'Chuck'),
 ('Bob', 'Alice'), ('Bob', 'Chuck')]
```

NetworkX 提供了几个绘图的功能；`draw_circular`将节点排列成一个圆，并使用边将它们连接：

```py

nx.draw_circular(G,
                 node_color=COLORS[0],
                 node_size=2000,
                 with_labels=True)
```

这就是我用来生成图（？）的代码。`with_labels`选项标注了节点；在下一个例子中，我们将看到如何标注边。

为了产生图（？），我们以一个字典开始，它将每个城市的名称，映射为对应的经纬度：

```py

pos = dict(Albany=(-74, 43),
           Boston=(-71, 42),
           NYC=(-74, 41),
           Philly=(-75, 40))
```

因为这是个无向图，我实例化了`nx.Graph`：

```py

G = nx.Graph()
```

之后我可以使用`add_nodes_from`来迭代`pos`的键，并将它们添加为节点。

```py

G.add_nodes_from(pos)
```

下面我会创建一个字典，将每条边映射为对应的驾驶时间。

```py

drive_times = {('Albany', 'Boston'): 3,
               ('Albany', 'NYC'): 4,
               ('Boston', 'NYC'): 4,
               ('NYC', 'Philly'): 2}
```

现在我可以使用`add_edges_from`，它迭代了`drive_times`的键，并将它们添加为边：

```py
G.add_edges_from(drive_times)
```

现在我不使用`draw_circular`，它将节点排列成一个圆圈，而是使用`draw`，它接受`pos`作为第二个参数：

```py

nx.draw(G, pos,
        node_color=COLORS[1],
        node_shape='s',
        node_size=2500,
        with_labels=True)
```

`pos`是一个字典，将每个城市映射为其坐标；`draw`使用它来确定节点的位置。

要添加边的标签，我们使用`draw_networkx_edge_labels`：

```py

nx.draw_networkx_edge_labels(G, pos,
                             edge_labels=drive_times)
```

`drive_times`是一个字典，将每条边映射为它们之间的驾驶距离，每条边表示为城市名称的偶对。这就是我生成图（？）的方式。

在这两个例子中，这些节点是字符串，但是通常它们可以是任何可哈希的类型。

## 2.3 随机图

随机图就像它的名字一样：一个随机生成的节点和边的图。当然，有许多随机过程可以生成图，所以有许多种类的随机图。

其中一个更有趣的是 Erdős-Rényi 模型，PaulErdős 和 AlfrédRényi 在 20 世纪 60 年代研究过它。

Erdős-Rényi 图（ER 图）的特征在于两个参数：`n`是节点的数量，`p`是任何两个节点之间存在边的概率。见 <http://en.wikipedia.org/wiki/Erdos-Renyi_model>。

Erdős 和 Rényi 研究了这些随机图的属性；其令人惊奇的结果之一就是，随着随机的边被添加，随机图的属性会突然变化。

展示这类转换的一个属性是连通性。如果每个节点到每个其他节点都存在路径，那么无向图是连通的。

在 ER 图中，当`p`较小时，图是连通图的概率非常低，而`p`较大时接近`1`。在这两种状态之间，在`p`的特定值处存在快速转变，表示为`p*`。

Erdős 和 Rényi 表明，这个临界值是`p* = lnn / n`，其中`n`是节点数。如果`p < p*`，随机图`G(n, p)`不太可能连通，并且如果`p > p*`，则很可能连通。

为了测试这个说法，我们将开发算法来生成随机图，并检查它们是否连通。

## 2.4 生成图

![](img/2-3.png)

我将首先生成一个完整的图，这是一个图，其中每个节点都彼此连接。

这是一个生成器函数，它接收节点列表并枚举所有不同的偶对。如果你不熟悉生成器函数，你可能需要阅读附录？，然后回来。

```py

def all_pairs(nodes):
    for i, u in enumerate(nodes):
        for j, v in enumerate(nodes):
            if i>j:
                yield u, v
```

你可以使用`all_pairs`来构造一个完全图。

```py

def make_complete_graph(n):
    G = nx.Graph()
    nodes = range(n)
    G.add_nodes_from(nodes)
    G.add_edges_from(all_pairs(nodes))
    return G
```

`make_complete_graph`接受节点数`n`，并返回一个新的`Graph`，拥有`n`个节点，所有节点之间都有边。

以下代码生成了一个包含 10 个节点的完全图，并绘制出来。

```py

complete = make_complete_graph(10)
nx.draw_circular(complete,
                 node_color=COLORS[2],
                 node_size=1000,
                 with_labels=True)
```

图（？）显示了结果。不久之后，我们将修改此代码来生成 ER 图，但首先我们将开发函数来检查图是否是连通的。

## 2.5 连通图

如果每个节点到每个其他节点都存在路径，这个图就是连通图。请见<http://en.wikipedia.org/wiki/Connectivity_(graph_theory)>。

对于许多涉及图的应用，检查图是否连通是很有用的。幸运的是，有一个简单的算法。

你可以从任何节点起步，并检查是否可以到达所有其他节点。如果你可以到达一个节点`v`，你可以到达`v`的任何一个邻居，他们是`v`通过边连接的任何节点。

`Graph`类提供了一个称为`neighbors`的方法，返回给定节点的邻居列表。例如，在上一节中我们生成的完全图中：

```py
>>> complete.neighbors(0)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

假设我们从节点`s`起步。我们可以将`s`标记为“已访问”，然后我们可以标记它的邻居。然后我们标记邻居的邻居，依此类推，直到你无法再到达任何节点。如果访问了所有节点，则图是连通图。

以下是 Python 中的样子：

```py

def reachable_nodes(G, start):
    seen = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in seen:
            seen.add(node)
            stack.extend(G.neighbors(node))
    return seen
```

`reachable_nodes`接受`Graph`和起始节点`start`，并返回可以从`start`到达的节点集合，他们。

最初，已访问的集合是空的，我们创建一个名为`stack`的列表，跟踪我们发现但尚未处理的节点。最开始，栈包含单个节点`start`。

现在，每次在循环中，我们：

+   从栈中删除一个节点。
+   如果节点已在`seen`中，我们返回到步骤 1。
+   否则，我们将节点添加到`seen`，并将其邻居添加到栈。

当堆栈为空时，我们无法再到达任何节点，所以我们终止了循环并返回。

例如，我们可以找到从节点`0`可到达的，完全图中的所有节点：

```py

>>> reachable_nodes(complete, 0)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

最初，栈包含节点`0`，`seen`是空的。第一次循环中，节点`0`添加到了`seen`，所有其他节点添加到了栈中（因为它们都是节点`0`的邻居）。

下一次循环中，`pop`返回栈中的最后一个元素，即节点`9.`因此，节点`9`被添加到`seen`，并且其邻居被添加到栈。

请注意，同一个节点在堆栈中可能会出现多次；实际上，具有`k`个邻居的节点将添加到堆栈`k`次。稍后我们将寻找方法，来使此算法更有效率。

我们可以使用`reachable_nodes`来编写`is_connected`：

```py

def is_connected(G):
    start = next(G.nodes_iter())
    reachable = reachable_nodes(G, start)
    return len(reachable) == len(G)
```

`is_connected`通过调用`nodes_iter`来选择一个起始节点，`node_iter`返回一个迭代器对象，并将结果传递给`next`，返回第一个节点。

`reachable`获取了一组节点，它们可以从`start`到达。如果这个集合的大小与图的大小相同，那意味着我们可以访问所有节点，也就是这个图是连通的。

一个完全图是连通的，毫不奇怪：

```py
>>> is_connected(complete)
True
```

下一节中，我们会生成 ER 图，并检查它们是否是连通的。


